import random
import sys
LETTERS = ['A', 'C', 'G', 'T']
EPS = 10**-10

class MathsIsHardException(Exception):
    pass

def read_DNA(filename):
    return [line.strip() for line in open(filename, 'rU').readlines()]

def print_matrix(dnalist):
    print "\n".join(dnalist)

def get_starting_positions(t, n, l):
    return [random.randint(0,n - l) for i in xrange(t)]

def create_profile(matrix):
    # letter -> list of normalised probabilities of letter appearing at index i in the matrix
    profile = {nucleotide : [0 for i in xrange(len(matrix[0])) ] for nucleotide in LETTERS}
    for i in xrange(len(matrix)):
        for j in xrange(len(matrix[i])):
            profile[matrix[i][j]][j] += 1

    #normalise
    for letter, scores in profile.iteritems():
        profile[letter] = [float(i) / len(matrix) for i in scores]
    return profile

def normalise(dist):
    summation= sum(dist)
    return [x / summation for x in dist] 

def get_generation_prob(lmer, profile):
    #the probability of the whole string is the product of the probability of each letter being generated in its position over all letters
    prob = 1 #start at 1 so we can multiply
    for i in xrange(len(lmer)):
        profile_prob = profile[lmer[i]][i]
        #this chance can be 0. We don't want to make the whole total 0, so use a very small value to approximate 0. TODO: is this a hack?
        if profile_prob == 0:
            prob *= EPS
        else:
            prob *= profile_prob
    return prob

def choose_from_distribution(dist):
    rand = random.random()
    for prob in dist:
        rand -= prob
        if rand <= 0:
            return dist.index(prob)
    raise MathsIsHardException, "Choosing from a distribution is hard. Did you make sure the distribution was normalised?"

def main():
    l = int(sys.argv[1])
    DNA = read_DNA('DNA.txt')

    #make sure all the sequences are the same length 
    assert len(set([len(s) for s in DNA])) == 1
    t = len(DNA) # number of sequences
    n = len(DNA[0]) # length of the sequences

    #we can't choose starting positions that cause subsequences that would overflow the length of the sequence
    starting_positions = get_starting_positions(t, n, l)

    while random.random() < 0.7:
        tuples = [DNA[i][starting_positions[i]: starting_positions[i] + l] for i in xrange(t)]
        print_matrix(DNA)
        print "Starting sequences: ", tuples

        #choose a sequence from the DNA sequences randomly
        sequence = random.choice(DNA)
        sequence_index = DNA.index(sequence)
        DNA.remove(sequence)
        profile = create_profile(tuples)
        print 'Profile: ', profile

        #for each position i in the chosen DNA sequence, find the probability that the lmer starting in this position is generated by the profile
        probs = []
        for i in xrange(n - l):
            lmer = sequence[i: i+ l]
            prob = get_generation_prob(lmer, profile)
            probs.append(prob)
        probs = normalise(probs)
        print probs

        new_starting_index = choose_from_distribution(probs)
        starting_positions[sequence_index]= new_starting_index

        #don't forget to put the sequence back
        DNA.insert(sequence_index, sequence)


if __name__ == "__main__":
    main()
